# 第五章 网络层：控制平面

## 1.导论

### 1.1 本章目标：理解网络层控制平面的==工作原理==

1. 传统路由选择算法
2. SDN控制器
3. ICMP：Internet Control Message Protocol
4. 网络管理
5. 以及它们在互联网上的==实例和实现：==
   + OSPF, BGP, OpenFlow, ODL 和ONOS控制器,  ICMP, SNMP

### 1.2 网络层功能

==回顾：2个网络层功能：==

1. ==转发：==将分组从路由器的一个输入端口移到合适的输出端口（数据平面）
2. ==路由：==确定分组从源到目标的路径（控制平面）

==2种构建网络控制平面功能的方法：==

1. 每个路由器控制功能实现（传统）
2. 逻辑上集中的控制功能实现（SDN）

##　２.路由选择算法

### 2.1 路由(route)

1. 路由的概念

   + 路由:按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径

     + 较好路径: 按照某种指标较小的路径

     + 指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均

     + 采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什 么指标网络使用者比较重视

   + 以==网络==为单位进行路由（路由信息通告+路由计算）

     + 网络为单位进行路由，路由信息传输、计算和匹配的代价低

     + 前提条件是：一个网络所有节点地址前缀相同，且物理上聚集

     + 路由就是：计算网络到其他网络如何走的问题

   + 网络到网络的路由=路由器-路由器之间的路由

     + 网络对应的路由器到其他网络对应的路由器的路由
     + 在一个网络中：路由器-主机之间的通信，链路层解决

     + 到了路由器就是到了这个网络

   + 路由选择算法：网络层软件的一部分，完成路由功能

2. 图抽象：边和路径的代价

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/1978f5a4e3a37c50b23249b30bf32b5f7ee273ca/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.1.png)

3. 最优化原则

   + 汇集树（sink tree)
     + 此节点到所有其他节点的最优路径形成的树
     + 路由选择算法就是为所有路由器==找到==并==使用==汇集树

4. 路由的原则

   + 正确性（correctness):算法必须是==正确==的和==完整==的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址；
   + 简单性(simplicity):算法在计算机上应简单：最优但复杂 的算法，时间上延迟很大，不实用，不应为了获取路由 信息增加很多的通信量；
   + 健壮性(robustness):算法应能适应==通信量==和==网络拓扑==的 变化：通信量变化，网络拓扑的变化算法能很快适应； 不向很拥挤的链路发数据，不向断了的链路发送数据；
   + 稳定性(stability)：产生的路由不应该摇摆
   + 公平性(fairness)：对每一个站点都公平
   + 最优性(optimality)：某一个指标的最优，时间上，费用 上，等指标，或综合指标；实际上，获取最优的结果代 价较高，可以是次优的

5. 路由算法分类

   ==全局或者局部路由信息？==

   全局：

   + 所有的路由器拥有完整的拓扑和边的代价的信息
   + “==link state==”算法

   分布式：

   + 路由器只知道与它有物理连接 关系的邻居路由器，和到相应 邻居路由器的代价值
   + 叠代地与邻居交换路由信息、 计算路由信息
   + “==distance vector=="算法

   ==静态或者动态的?==

   静态:(非自适应算法：不能适应网络拓扑和通信量的变化，路由表是事先计算好的)

   + 路由随时间变化缓慢

   动态:(自适应路由选择：能适应网络拓扑和通信量的变化)

   + 路由变化很快
     + 周期性更新
     + 根据链路代价的变化而变化

### 2.2 link state 算法

1. 配置==LS路由选择算法==的路由工作过程

   + 各点通过各种渠道获得==整个网络拓扑==, 网络中所有链路==代价==等信息（这部分和算法没关系，属于协议和实现）
   + 使用==LS路由算法==,计算本站点到其它站点的最优路径(汇 集树),得到路由表
   + 按照此路由表转发分组(datagram方式)
     + 严格意义上说不是路由的一个步骤
     + 分发到输入端口的网络层

   + ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/539c7562cf9393b3aca57b89c32cf05f9a514c7a/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.2.png)

2. 链路状态路由选择（link state routing)

   + LS路由的基本工作过程
     1. 发现相邻节点,获知对方网络地址
     2. 测量到相邻节点的代价(延迟,开销)
     3. 组装一个LS分组,描述它到相邻节点的代价情况
     4. 将分组通过扩散的方法发到所有其它路由器 以上4步让每个路由器获得==拓扑==和==边代价==
     5. 通过Dijkstra算法找出最短路径（这才是路由算法）
        1. 每个节点独立算出来到其他节点（路由器=网络）的最短路径
        2. 迭代算法：第k步能够知道本节点到k个其他节点的最 短路径

3. LS路由工作过程第一步

   第一步：==发现相邻节点，获知对方网络地址==

   + 一个路由器上电之后,向所有线路发送HELLO分组
   + 其它路由器收到HELLO分组,回送应答,在应答分组中,告 知自己的名字(全局唯一)
   + 在LAN中,通过广播HELLO分组,获得其它路由器的信息, 可以认为引入一个人工节点
   + ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/539c7562cf9393b3aca57b89c32cf05f9a514c7a/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.3.png)

4. LS路由工作过程第二步、第三步

   第二步：==测量到相邻节点的代价(延迟，开销)==

   + 实测法,发送一个分组要求对方立即响应
   + 回送一个ECHO分组
   + 通过测量时间可以估算出延迟情况

   第三步：==组装一个分组，描述相邻节点的情况==

   + 发送者名称
   + 序号,年龄
   + 列表: 给出它相邻节点,和它到相邻节点的延迟
   + ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/539c7562cf9393b3aca57b89c32cf05f9a514c7a/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.4.png)

5. LS路由工作过程第四步

   第四步：==将分组通过扩散的方法发到所有其他路由器==

   + 顺序号：用于控制无穷的扩散,每个路由器都记录( 源路由器,顺序号),发现重复的或老的就不扩散
     + 具体问题1: 循环使用问题
     + 具体问题2: 路由器崩溃之后序号从0开始
     + 具体问题3:序号出现错误
   + 解决问题的办法：年龄字段（ege)
     + 生成一个分组时，年龄字段不为0
     + 每个一个时间段，AGE字段减1
     + AGE字段为0的分组将被抛弃
   + 关于扩散分组的数据结构
     + Source :从哪个节点收到LS分组
     + Seq,Age:序号,年龄
     + Send flags:发送标记,必须向指定的哪些相邻站点转发LS分组
     + ACK flags:本站点必须向哪些相邻站点发送应答
     + DATA:来自source站点的LS分组
     + 节点B的数据结构
     + ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/539c7562cf9393b3aca57b89c32cf05f9a514c7a/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.5.png)
   
6. LS路由工作过程第五步

   第五步：==通过Dijkstra算法找出最短路径==

   + 路由器获得各站点LS分组和整个网络的拓扑
   + 通过Dijkstra算法计算出到其它各路由器的最短路径(汇集树)
   + 将计算结果安装到路由表中

7. 符号标记：

   ==C(i,j)==：从节点i 到j链路代价(初始状态下非相邻节点之间的 链路代价为∞)

   ==D(v)==:从源节点到节点V的当前路径代价(节点的代价)

   ==p(v)==:从源到节点V的路径前序节点

   ==N'==:当前已经知道最优路径的的节点集合(永久节点的集合)

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/405a8ff963e0ed2cb052553ae8baf3960b613c68/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.6.png)

8. LS路由选择算法的工作原理

   1. 节点标记: 每一个节点使用(D(v),p(v)) 如： (3,B)标记

      + D(v)从源节点由已知最优路径到达本节点的距离
      + P(v)前序节点来标注

   2. 2类节点

      + 临时节点(tentative node) :还没有找到从源 节点到此节点的最优路径的节点
      + 永久节点(permanent node) N’:已经找到了从 源节点到此节点的最优路径的节点

   3. 初始化

      + 除了源节点外,所有节点都为临时节点
      + 节点代价除了与源节点代价相邻的节点外,都为∞

      ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/405a8ff963e0ed2cb052553ae8baf3960b613c68/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.7.png)

9. Dijkstra算法的讨论

   ==算法复杂度：==n节点

   + 每一次迭代: 需要检查所有不在永久集合N中节点
   + n(n+1)/2 次比较: O(n2 )
   + 有很有效的实现: O(nlogn)

   ==可能的震荡：==

   + e.g.,链路代价=链路承载的流量:

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/405a8ff963e0ed2cb052553ae8baf3960b613c68/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/5.2.8.png)