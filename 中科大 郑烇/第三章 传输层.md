# 第三章 传输层

## 1、概述和传输层服务

### 1.1 第三章：传输层

**目标：**

1. 理解传输层的工作原理
   + 多路复用/解复用
   + 可靠数据传输
   + 流量控制
   + 拥塞控制
2. 学习Internet的传输层协议
   + UDP：无连接传输
   + TCP：面向连接的可靠传输
   + TCP的拥塞控制

### 1.2 第三章：提纲

1. 概述和传输层服务

2. 多路复用与解复用

3. 无连接传输：UDP

4. 可靠数据传输的原理

5. 面向连接的传输：

   TCP

   + 段结构
   + 可靠数据传输
   + 流量控制
   + 连接管理

6. 拥塞控制原理

7. TCP拥塞控制

###  1.3 传输服务和协议

1. 为运行在不同主机上的应用进程提供逻辑通信
2. 传输协议运行在端系统
   + 发送方：将应用层的报文分成==报文段==，然后传 递给网络层
   + 接收方：将报文段重组成报文，然后传递给应 用层
3. 有多个传输层协议可提供选择：
   + Internet:TCP和UDP

### 1.4 传输层 VS 网络层

1. 网络层服务：主机之间的逻辑通信

2. 传输层服务：进程间的逻辑通信

   + 依赖于网络层的服务：延时、带宽
   + 并对网络层的服务进行增强：数据丢失、顺序混乱、加密
   + 有些服务是可以加强的：不可靠 -> 可靠；安全 
   + 但有些服务是不可以被加强的：带宽，延迟

3. 类比：东西2个家庭的通信

   Ann家的12个孩子给Bill家的12个小孩发信

   + 主机 = 家
   + 进程 = 小孩
   + 应用层报文= 信封中的信件
   + 传输协议= Ann 和 Bill
     + 为家庭小孩提供复用解复用服务
   + 网络层协议 = 邮政服务
     + 家庭-家庭的邮包传输服务



### 1.5 Internet传输层协议

1. 可靠的、保序的传输：TCP
   + 多路复用、解复用
   + 拥塞控制
   + 流量控制
   + 建立连接
2. 不可靠、不保序的传输：UDP
   + 多路复用、解复用
   + 没有为尽力而为的IP服务添加更多的其它额外服务
3. 都不提供的服务：
   + 延时保证
   + 带宽保证

## 2、多路复用与解复用

### 2.1 多路复用/解复用

![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.1.png)

### 2.2 多路解复用工作原理

UDP和TCP不同

![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.1.png)

1. 解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确 的进程
2. 主机收到IP数据报
   + 每个数据报有源IP地址和目标地址
   + 每个数据报承载一个传输层报文段
   + 每个报文段有一个源端口号和目标端口号(特定应用有著名的端口号)
3. 主机联合使用IP地址和端口号将报文段发送给合适的套接字

### 2.3 无连接(UDP)多路解复用

1. 创建套接字：

   ==服务器端：==

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.1.png)

   serverSocket和Sad指定的端口号捆绑

   ==客户端：==

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.4.png)

   > 没有Bind,ClientSocket和OS为之分配的某个端口号捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）

2. 在接收端，UDP套接字用二元组标示（目标IP地址、目标端口号）

3. 当主机收到UDP报文段：

   + 检查报文段的目标端口号
   + 用该端口号将报文段定位给套接字

4. 如果两个不同源IP地址/源端口号的数据报，但是有==相同的目标IP地址和端口号==，则被定位到相同的套接字

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.5.png)

5. 无连接多路复用：例子

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.6.png)

### 2.4 面向连接（TCP）的多路复用

1. TCP套接字：四元组本地标识：

   + 源IP地址
   + 源端口号
   + 目的IP地址
   + 目的端口号

2. ==解复用：==接收主机用这四个值来将数据报定位到合适的套接字

3. 服务器能够在一个TCP端口上同时支持多个TCP套接字：

   + 每个套接字由其四元组标识（有不同的源IP和源PORT）

4. Web服务器对每个连接客户端有不同的套接字

   + 非持久对每个请求有不同的套接字

5. 面向连接的解复用：例子

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/3020409b77547334481d0056c84ac82dbd781bc9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.2.7.png)

## 3、无连接传输：UDP

### 3.1 UDP：User Datagram Protocol [RFC 768]

1. “no frills,” “bare bone”Internet 传输协议
2. “尽力而为”的服务，报文段可能：
   +  丢失
   + 送到应用进程的报文段乱序
3. ==无连接：==
   + UDP发送端和接收端之间没有握手
   + 每个UDP报文段都被独立地处理
4. UDP被用于：
   + 流媒体（丢失不敏感，速率敏感、应用可控制 传输速率）
   + DNS
   + SNMP
5. 在UDP上可行可靠传输:
   + 在应用层增加可靠性
   + 应用特定的差错恢复

### 3.2 UDP:用户数据报协议

![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/cd5152e09ce2722d887b6d73175766286df2c7fb/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.3.1.png)**为什么要有UDP?**

1. 不建立连接（会增加延时）
2. 简单：在发送端和接收端没有连接状态
3. 报文段的头部很小(开销小)
4. 无拥塞控制和流量控制：UDP可以尽可能快的发送报文段
   + 应用->传输的速率= 主机->网络的速率

### 3.3 UDP校验和

1. ==目标==：检测在被传输报文段中的差错(如比特反转)
2. ==发送方：==
   + 将报文段的内容视为16比特的整数
   + 校验和：报文段的加法和(1的补运算）
   + 发送方将校验和放在UDP的校验和字段
3. ==接收方：==
   + 计算接收到的报文段的校验和
   + 检查计算出的校验和与校验 和字段的内容是否相等：
     + 不相等–--检测到差错
     + 相等–--没有检测到差错 ，但也许还是有差错：残存错误

### 3.4 Internet校验和的例子

1. 注意：当数字相加时，在最高位的进位要回卷，再加到结果上

   ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/cd5152e09ce2722d887b6d73175766286df2c7fb/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.3.2.png)

   2. 目标端：校验范围+校验和=1111111111111111 通过校验
      + 否则没有通过校验
   3. 注：求和时，必须将进位回卷到结果上
   

## 4、可靠数据传输的原理

### 4.1 可靠数据传输（rdt)

**rdt的原理**

1. rdt在应用层、传输层和数据链路层都很重要

2. 是网络Top 10问题之一

3. ![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.1.png)

4. 信道的不可靠特点决定了可靠数据传输协议（rdt)的复杂性

**可靠数据传输：问题描述**
![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.2.png)
我们将：

1. 渐增式地开发可靠数据传输协议（ rdt ）的发送方和接
收方
2. 只考虑单向数据传输
	+ 但控制信息是双向流动的！
3. 双向的数据传输问题实际上是2个单向数据传输问题的综
合
4. 使用有限状态机 (FSM) 来描述发送方和接收方
	![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.3.png)
### 4.2 Rdt1.0:在可靠信道上的可靠数据传输
1. 下层的信道是完全可靠的
	+ 没有比特出错
	+ 没有分组丢失
2. 发送方和接收方的FSM
	+ 发送方将数据发送到下层信道
	+ 接收方从下层信道接收数据
	![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.4.png)
### 4.3 Rdt2.0：具有比特差错的信道
1. 下层信道可能会出错：将分组中的比特翻转
	+ 用校验和来检测比特差错
2. 问题：怎样从差错中恢复：
	+ ==确认(ACK)==：接收方显式地告诉发送方分组已被正确接收
	+ ==否定确认(NAK)==: 接收方显式地告诉发送方分组发生了差错
		+ 发送方收到NAK后，发送方重传分组
3. rdt2.0中的新机制：采用差错控制编码进行差错检测
	+ 发送方差错控制编码、缓存
	+ 接收方使用编码检错
	+ 接收方的反馈：控制报文（ACK，NAK）：接收方->发送方
	+ 发送方收到反馈相应的动作
4. rdt2.0:FSM描述
![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.5.png)
5. rdt2.0:没有差错时的操作
![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.6.png)
6. rdt2.0：有差错时
![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.7.png)
### 4.4 rdt2.1
1. rdt2.0的致命缺陷->rdt2.1
**如果ACK/NAK出错？**
	+ 发送方不知道接收方发生了什么事情！
	+ 发送方如何做？
		+ 重传？可能重复
		+ 不重传？可能死锁(或出错)
	+ 需要引入新的机制
		+ 序号
	**处理重复：**
	+ 发送方在每个分组中加入序号
	+ 如果ACK/NAK出错，发送方重传当前分组
	+ 接收方丢弃（不发给上层）重复分组
**停等协议**
发送方发送一个分组，然后等待接收方的应答
2. rdt2.1：发送方处理出错的ACK/NAK
![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.8.png)
3. rdt2.1：接收方处理出错的ACK/NAK
![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.9.png)
4. rdt2.1:讨论
	**发送方：**
	+ 在分组中加入序列号
	+ 两个序列号（0，1）就足够了
		+ 一次只发送一个未经确认的分组
	+ 必须检测ACK/NAK是否出错（需要EDC）
	+ 状态数变成了两倍
		+ 必须记住当前分组的序列号为0还是1
		**接收方：**
	+ 必须检测接收到的分组是否是重复的
		+ 状态会指示希望接收到的分组的序号为0还是1
	+  注意：接收方并不知道发送方是否正确收到了其ACK/NAK
		+ 没有安排确认的确认
		+ 具体解释见下页
5. rdt2.1的运行
	![](https://gitee.com/xatu-han-chen/computer-network-learning/raw/aeafaa47fd65a23f86bf15f77c938222b25a46d9/%E4%B8%AD%E7%A7%91%E5%A4%A7%20%E9%83%91%E7%83%87/resource/3.4.10.png)
	接收方不知道它最后发送的ACK/NAK是否被正确地收到
	+ 发送方不对收到的ack/nak给确认，没有所谓的确认的确认
	+ 接收方发送ack，如果后面接收方收到的是：
		+ 老分组p0？则ack 错误
		+ 下一个分组？P1，ack正确
